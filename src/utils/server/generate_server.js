import { Logger } from './../logger.js';
import { is_func } from './../validate.js';
import { Cwd } from '../../vars/cwd.js';
import { route_request, fallback_route_request, apply_response } from '../../action/route.js';
import { config_from_url, get_buffer } from './../media.js';
import { wait_for } from './../wait.js';
import { exists, read, remove, to_extension, write } from './../file.js';
import { WorkerController } from '../../worker/controller.js';
import { WorkerAction } from '../../struc/worker_action.js';
import { basename, join } from 'node:path';
import { pub_healthcheck } from './../health.js';
import { register_stack } from './../global.js';
import { media } from '../../action_worker/media.js';
import { IsWorker } from '../../vars/is_worker.js';
import { build_hydrate_file_from_url } from './../script.js';
import { ReleasePath } from '../../vars/release_path.js';
import { server } from './server.js';
import { static_server } from './static_server.js';
import { ServerShowRequests } from '../../vars/server_show_requests.js';

export async function generate_server(port, force_generating_of_resources, onEnd, fallback) {
    register_stack();

    server(port, undefined, async (req, res, uid) => {
        // check if pub is available
        pub_healthcheck();
        // check for media files
        const name = basename(req.url);
        const media_config = await config_from_url(req.url);
        if (media_config && !media_config.result_exists) {
            let buffer = await get_buffer(media_config.src);
            if (buffer) {
                buffer = undefined;
                const start = process.hrtime.bigint();
                // generate media on demand
                if (IsWorker.get()) {
                    await media([media_config]);
                } else {
                    await WorkerController.process_data(WorkerAction.media, [media_config]);
                }
                // the file needs some time to be available after generation started
                const success = await wait_for(() => {
                    return exists(Cwd.get(media_config.result));
                });
                if (ServerShowRequests.get()) {
                    Logger[success ? 'success' : 'error']('media', name, ...get_time_log_infos(start, uid));
                }
            }
        }

        await static_server(req, res, uid, async (err) => {
            if (err) {
                // check if css or js files should be generated
                if (req.url.indexOf('/js') === 0) {
                    const file_content = await build_hydrate_file_from_url(req.url);
                    if (file_content) {
                        res = send_head(res, 200, 'application/javascript');
                        res.end(file_content);
                        return;
                    }
                }

                // handle request and hydrequest component rendering
                if (req.method.toLowerCase() === 'post' && req.url.indexOf('/$src/') === 0) {
                    console.log('request rendering', req.url);
                }

                const ghost_path = join(ReleasePath.get(), req.url.replace(/\/(?:index\.html)?$/, '/index.ghost'));
                const shadow_path = to_extension(ghost_path, '.shadow');
                let ghost_delivered = false;

                if (exists(ghost_path)) {
                    const content = read(ghost_path);
                    if (content) {
                        res = send_head(res, 200, 'text/html');
                        res.end(content);
                        ghost_delivered = true;
                    }
                    // stop after delivering the ghost file, because the file is already generated by another process call
                    if (exists(shadow_path)) {
                        return;
                    }
                    // add marker that the file is in progress
                    write(shadow_path, '');
                }

                const route_response = await route_request(req, res, uid, force_generating_of_resources);

                // when ghost file was delivered, remove it and also the shadow file
                if (ghost_delivered) {
                    remove(ghost_path);
                    remove(shadow_path);
                    return;
                }
                if (route_response) {
                    res = apply_response(res, route_response);
                    return;
                }
                if (!route_response.complete) {
                    if (is_func(fallback)) {
                        await fallback(req, res, uid, err);
                        return false;
                    }
                    // fallback_route_request returns an response
                    const fallback_route_response = await fallback_route_request(req, res, uid);
                    if (fallback_route_response) {
                        res = apply_response(res, fallback_route_response);
                        return;
                    }
                }
                return false;
            }
            return true;
        });
    });
}
